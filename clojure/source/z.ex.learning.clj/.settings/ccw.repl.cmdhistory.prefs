cmdhistory=["(def x 5)" "(defn x-one [num] (+ num 5))" "(x-one x)" "(defun x-two [num] (+ num 10))" "(getf (list \:one 1 \:two 2 \:three 3) \:one)" "(def list-keys (list \:one 1 \:two 2 \:three 3))" "(getf list-keys \:one)" "(get list-keys \:one)" "(println Person)" "(println n1)" "(println paul-person)" "(-> paul-person \:employer \:address \:street)" "(n-add-five n1)" "(println a-length)" "(print a-count)" "(defn to-lower-case\\n  [token-str] \\n  (.toLowerCase token-str))" "(def pre-tokenized-list \\n  '(\\"Paul\\" \\"was\\" \\"here\\"))" "(def processed-list \\n  (to-lower-case pre-tokenized-list))" "(def processed-list \\n  (map to-lower-case pre-tokenized-list))" "(println processed-list)" "(def stop-words\\n  \#{\\"a\\" \\"in\\" \\"that\\" \\"for\\" \\"was\\" \\"is\\"\\n    \\"it\\" \\"the\\" \\"of\\" \\"and\\" \\"to\\" \\"he\\"})" "(contains? stop-words \\"and\\")" "(contains? stop-words \\"paul\\")" "(def my-integers\\n  '(-3 -2 -1 0 1 2 3))" "(def my-natural-numbers\\n  (filter pos? my-integers))" "(println my-natural-numbers)" "(def set-complement\\n  (complement (contains? stop-words \\"that\\")))" "(println set-complement)" "(set-complement)" "(println \\n  set-complement)" "(println (.valueOf set-complement))" "(defn set-complement-2\\n  (complement (contains? stop-words \\"that\\")))" "(defn set-complement-2\\n  [stop-words]\\n  (complement (contains? stop-words \\"that\\")))" "(set-complement-2 stop-words)" "(defn say-hi\\n  []\\n  (println \\"Hello, world\!\\")\\n  [name]\\n  (println (str \\"Hello, \\" name \\"\!\\")))" "(say-hi)" "(defn say-hi\\n  ([]\\n  (println \\"Hello, world\!\\"))\\n  ([name]\\n  (println (str \\"Hello, \\" name \\"\!\\"))))" "(say-hi)" "(say-hi \\"Paul\\")" "(defn say-hi\\n  ([]\\n  (say-hi \\"world\\"))\\n  ([name]\\n  (println (str \\"Hello, \\" name \\"\!\\"))))" "(say-hi)" "(say-hi \\"Paul\\")" "(say-hi)" "(say-hi \\"Paul\\")" "(conj '(1 2 3)  4)" "(conj [1 2 3] 4)" "(def tmp-map {\\"one\\" 1, \\"two\\" 2, \\"three\\" 3})" "(count tmp-map)" "(assoc tmp-map \\"four\\" 4)" "(disassoc tmp-map \\"two\\")" "(dissoc tmp-map \\"two\\")" "(defrecord word-data [word frequency])" "(def the-word (word-data. \\"the\\" 400))" "(println the-word)" "(\:word the-word)" "(\:frequency the-word)" "(-> the-word \:word)" "(assoc the-word \:location 'here)" "(let [age (\:age person)]\\r\\n  (if age\\r\\n    (str \\"My age is \\" age)\\r\\n    \\"No age given\\"))" "(def person {\:name \\"Paul Webster\\" \:age 42})" "(let [age (\:age person)]\\r\\n  (if age\\r\\n    (str \\"My age is \\" age)\\r\\n    \\"No age given\\"))" "(def tmp-word (make-stemmer \\"explanation\\"))" "(def tmp-word (porter/make-stemmer \\"explanation\\"))" "(porter/get-index tmp-word)" "(porter/subword tmp-word)" "(porter/pop-word tmp-word)" "(let [greet (fn [n] (str \\"Hello, \\" n))]\\r\\n         (map greet '(Paul Remy)))" "(let [cp (fn ([] 0)\\r\\n                    ([a] 1)\\r\\n                    ([a b] 2)\\r\\n                    ([a b c] 3))]\\r\\n         [(cp 'p0 'p1) (cp)])" "(defn count-item [sequence item]\\r\\n  \\"If empty, return 0.  If found, return +1 of the rest  of the list count.  if not found, return the rest of the list count\\"\\r\\n  (if (not (seq sequence))\\r\\n    0\\r\\n    (if (\= (peek sequence) item)\\r\\n      (inc (count-item (pop sequence) item))\\r\\n      (count-item (pop sequence) item))))" "(count-item '(1 2 3 2 3 4 3 4 5) 2)" "(count-item '(1 2 3 2 3 4 3 4 5) 1)" "(count-item '(1 2 3 2 3 4 3 4 5) 3)" "(count-item '(1 2 3 2 3 4 3 2 1) 2)" "(count-item-loop '(1 2 3 2 3 4 3 2 1) 2)" "(zero? 1)" "(zero? 0)" "(defn count-item-cond \\r\\n  [sequence item]\\r\\n  (loop [sq sequence, accum 0]\\r\\n    (cond (not (seq sq)) accum\\r\\n          (\= (peek sq) item) (recur (pop sq) (inc accum))\\r\\n          \:else (recur (pop sq) accum))))" "(count-item-cond '(1 2 3 2 3 4 3 2 1) 2)" "(let [j 6]\\n  (loop [i 0]\\n    (cond (> i j) false\\n          (pos? i) (recur (inc i))\\n          \:else true)))" "(let [j 6]\\n  (loop [i 0]\\n    (cond (> i j) false\\n          (pos? i) ((prinln i) (recur (inc i)))\\n          \:else true)))" "(let [j 6]\\n  (loop [i 0]\\n    (cond (> i j) false\\n          (pos? i) (recur (inc i))\\n          \:else true)))" "(def station (porter/make-stemmer \\"station\\"))" "(println station)" "(porter/get-index station)" "(porter/subword station)" "(porter/pop-word station)" "(def st ((porter/pop-word station)))" "(def st (porter/pop-word station))" "(println st)" "(porter/get-index st)" "(porter/subword st)" "(porter/reset-index st)" "(porter/reset-index (\:word st))" "(doc porter/reset-index)" "(println station)" "(println st)" "(count-item '(1 2 3 4 5 6) 3)" "(defn member-cond?\\r\\n  [sequence item]\\r\\n  (loop [sq sequence]\\r\\n    (cond (not (seq sq)) nil\\r\\n          (\= (peek sq) item) sq\\r\\n          \:else (recur (pop sq) item))))" "(defn member-cond?\\r\\n  [sequence item]\\r\\n  (loop [sq sequence]\\r\\n    (cond (not (seq sq)) nil\\r\\n          (\= (peek sq) item) sq\\r\\n          \:else (recur (pop sq)))))" "(member-cond? '(1 2 3 4 5 6) 7)" "(member-cond? '(1 2 3 4 5 6) 4)" "(def test? \#{ \:one \:two \:three\: })" "(def test? \#{ \:one \:two \:three})" "(test? \:four)" "(test? \:two)" "(def my-st (porter/make-stemmer \\"Floating\\"))" "(println my-st)" "(nth (\:word my-st) (get-index my-st))" "(nth (\:word my-st) (porter/get-index my-st))" "(nth (\:word my-st) 5)" "(porter/consonant? my-st)" "(porter/consonant? my-st 5)" "(not-zero? 0)" "(not-zero? 5)" "(porter/vowel-in-stem? my-st)" "(def my-cc (porter/maker-stemmer \\"nbnbnbnb\\"))" "(def my-cc (porter/make-stemmer \\"nbnbnbnb\\"))" "(porter/vowel-in-stem? my-cc)" "(defn count-item-internal-fn \\r\\n  [sequence item]\\r\\n  (let [ci (fn [sq accum]\\r\\n             (cond (not (seq sq)) accum\\r\\n                   (\= (peek sq) item) (recur (pop sq) (inc accum))\\r\\n                   \:else (recur (pop sq) accum)))]\\r\\n    (ci sequence 0)))" "(count-item-internal-fn '( 1 2 3 5 3 5 4 3 ) 3)" "(count-item-internal-fn '( 1 2 3 5 3 5 4 3 2 3 5 3 6) 3)" "(porter/m my-st)" "(porter/m my-cc)" "(defn my-vec [in]\\n  ([in (count in)]))" "(my-vec \\"Paul\\")" "(defn my-vec [in]\\n  [in (count in)])" "(my-vec \\"Paul\\")" "(let  [ [word length] (my-vec \\"Paul\\") ]\\n  (println (str \\"I found \\" length \\" chars in \\" word)))" "(def my-vec-output\\r\\n  (let  [ [word length] (my-vec \\"Paul\\") ]\\r\\n     (println (str \\"I found \\" length \\" chars in \\" word))))" "(def my-vec-output\\r\\n  (let  [ [word length] (my-vec \\"Paul\\") ]\\r\\n     (str \\"I found \\" length \\" chars in \\" word)))" "(println my-vec-output)" "(println paul-person)" "(let [age (\:age person)]\\r\\n  (if age\\r\\n    (str \\"My age is \\" age)\\r\\n    \\"No age given\\"))" "(println person)" "(\:name person)" "(say-hi \\"Terri\\")" "(let [greet (fn [n] (str \\"Hello, \\" n))]\\r\\n  (map greet '(Paul Remy)))" "(println my-vec-output)" "(println person)" "(\:age person)" "(\:name paul-person)" "(println paul-person)" "(assoc \:province \\"ON\\" (\:address (\:employer paul-person)))" "(assoc (\:address (\:employer paul-person)) \:province \\"ON\\" )" "(let [p paul-person, emp (\:employer paul-person), addr (\:address emp)]\\n  (assoc paul-person \:employer (assoc emp \:address (assoc addr \:province \\"ON\\"))))" "(def paul-person-prov (let [p paul-person, emp (\:employer paul-person), addr (\:address emp)]\\r\\n     (assoc paul-person \:employer (assoc emp \:address (assoc addr \:province \\"ON\\")))))" "(println paul-person-prov)"]
eclipse.preferences.version=1
